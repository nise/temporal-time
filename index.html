<!--
TODO
- bug at time difference
- done: fix time after midnight
- done: fix time diff
- done: deploy as github page
-->
<!DOCTYPE html>
<html>

<head>
    <title>Temporalzeit</title>
    <meta charset="UTF-8">
    <link rel="manifest" href="./manifest.json">
    <script src="https://unpkg.com/vue"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"
        integrity="sha512-bZS47S7sPOxkjU/4Bt0zrhEtWx0y0CRkhEp8IckzK+ltifIIE9EMIMTuT/mEzoIMewUINruDBIR/jJnbguonqQ=="
        crossorigin="anonymous"></script>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <style>
        body {
            background: #fff;
            font-family: Arial;
            max-width: 100%;
            margin: 20px auto;
            line-height: 1.2em;
            font-size: 20px;
        }

        h1 {
            margin-top: 0px;
        }

        svg {
            stroke: #000;
            font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
            width: 100%;
        }

        #rim {
            fill: none;
            stroke: #999;
            stroke-width: 3px;
        }

        .second-hand {
            stroke-width: 3;

        }

        .minute-hand {
            stroke-width: 8;
            stroke-linecap: round;
        }

        .hour-hand {
            stroke-width: 12;
            stroke-linecap: round;
        }

        .hands-cover {
            stroke-width: 3;
            fill: #fff;
        }

        .second-tick {
            stroke-width: 3;
            fill: #000;
        }

        .hour-tick {
            stroke-width: 8; //same as the miute hand
        }

        .second-label {
            font-size: 1em;
        }

        .hour-label {
            font-size: 2em;
        }


        #app {
            display: table;
            text-align: center;
            margin: 20px auto;
        }

        .time,
        .details {
            text-align: center;
            margin: 0px auto;
            padding: 0 10%;
        }

        .details {
            width: 80%;
            font-size: medium;
            margin-bottom: 0;
        }

        .details ul {
            text-align: left;
            list-style-type: none;
            margin: 0 auto;
        }

        .time h4,
        .details h4 {
            margin-bottom: 4px;
            margin: 0 6px 4px 6px;
        }

        .details h4 {
            text-align: left;
        }

        .time-cell {
            display: inline-block;
            text-align: center;
            vertical-align: top;
            font-size: 1.2em;
            line-height: 1.2em;
        }

        .note {
            color: darkred;
            font-size: small;
        }

        .footer {
            font-size: 0.6em;
            color: #999;
            margin: 100px auto 0px auto;
        }

        .footer a {
            text-decoration: none;
            color: darkblue;
        }

        .language-toggle {
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 80px;
            font-size: 0.8em;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="app" class="container">
        <div class="language-toggle btn btn-secondary"
            @click="selectedLanguage = selectedLanguage === 'de' ? 'en' : 'de'">
            {{ selectedLanguage === 'de' ? 'ðŸ‡¬ðŸ‡§ English' : 'ðŸ‡©ðŸ‡ª Deutsch' }}
        </div>
        <h1 v-html="lang('temporalTime')"></h1>
        <div class="time">
            <div class="time-cell">
                <h4 v-html="lang('temporalTime')"></h4>
                <span>{{ getFormatedTime("temporal") }}</span><br>
                <span hidden v-html="lang('difference')" class="note"></span>
                <span hidden class="note"> {{ timeDifference }} Min</span>
            </div>
            <div class="time-cell">
                <h4 v-html="lang('localTime')"></h4>
                <span>{{ getFormatedTime("local") }}</span>
            </div>
            <div class="time-cell">
                <h4 v-html="lang('solarTime')"></h4>
                <span>{{ getFormatedTime("solar") }}</span>
            </div>
        </div>
        <div id="clock"></div>
        <div class="details">
            <h4 v-html="lang('details')"></h4>
            <ul>
                <li><span v-html="lang('long')"></span> {{long}}</li>
                <li><span v-html="lang('lat')"></span></span> {{lat}}</li>
                <li><span v-html="lang('sunrise')"></span></span> {{rise.getHours()
                    }}:{{rise.getMinutes()}}:{{rise.getSeconds()}}</li>
                <li><span v-html="lang('sunset')"></span> {{down.getHours()
                    }}:{{down.getMinutes()}}:{{down.getSeconds()}}</li>
            </ul>
        </div>
        <div class="details">
            <h4 v-html="lang('reading')"></h4>
            <ul>
                <li><a href="https://en.wikipedia.org/wiki/Unequal_hours">Unequal Hours (English)</a></li>
                <li><a href="https://de.wikipedia.org/wiki/Temporale_Stunden">Temporalzeit (Deutsch)</a></li>
                <li><a href="https://www.nise81.com/archives/3978">Die Temporaluhr: Stunden, die sich an
                        Sonnenauf- und -untergang anpassen (Deutsch)</a></li>
            </ul>
        </div>
        <div class="footer">
            By <a href="https://www.nise81.com">Niels Seidel</a>, 2025 | see source code at <a
                href="https://github.com/nise/temporal-time">GitHub</a> |
            credits:
            <a href="http://bl.ocks.org/tomgp/6475678">tomgp's clock</a>
        </div>
    </div>
    <script type="module">
        const { createApp } = Vue;
        createApp({
            el: '#app',
            data() {
                return {
                    time: new Date(),
                    sunHour: 0,
                    sunMinute: 0,
                    temporalHour: null,
                    temporalMinute: null,
                    timeDifference: 0,
                    rise: new Date(),
                    down: new Date(),
                    lat: 0,
                    long: 0,
                    tmp: 0,
                    // clock display
                    handData: [],
                    radians: 0.0174532925,
                    clockRadius: 250,
                    margin: 50,
                    hourHandLength: 0,
                    width: 0,
                    height: 0,
                    hourHandLength: 0,
                    minuteHandLength: 0,
                    secondHandLength: 0,
                    secondHandBalance: 30,
                    secondTickStart: 0,
                    secondTickLength: -10,
                    hourTickStart: 0,
                    hourTickLength: -18,
                    secondLabelRadius: 0,
                    secondLabelYOffset: 5,
                    hourLabelRadius: 0,
                    hourLabelYOffset: 7,
                    selectedLanguage: "de",
                    language: {
                        "de": {
                            "temporalTime": "Temporalzeit",
                            "localTime": "Ortszeit",
                            "solarTime": "Sonnenzeit",
                            "difference": "Differenz: ",
                            "details": "Details",
                            "reading": "Weitere Informationen",
                            "long": "LÃ¤ngengrad:",
                            "lat": "Breitengrad:",
                            "sunrise": "Sonnenaufgang:",
                            "sunset": "Sonnenuntergang:",
                        },
                        "en": {
                            "temporalTime": "Temporal Time",
                            "localTime": "Local Time",
                            "solarTime": "Sun Time",
                            "difference": "Difference: ",
                            "details": "Details",
                            "reading": "Further reading",
                            "long": "Longitude:",
                            "lat": "Latitude:",
                            "sunrise": "Sunrise:",
                            "sunset": "Sunset:",
                        }
                    },

                };
            },

            mounted() {
                this.width = (this.clockRadius + this.margin) * 2;
                this.height = (this.clockRadius + this.margin) * 2;
                this.hourHandLength = 2 * this.clockRadius / 3;
                this.minuteHandLength = this.clockRadius;
                this.secondHandLength = this.clockRadius - 12;
                this.secondHandBalance = 30;
                this.secondTickStart = this.clockRadius;
                this.secondTickLength = -10;
                this.hourTickStart = this.clockRadius;
                this.hourTickLength = -18;
                this.secondLabelRadius = this.clockRadius + 16;
                this.secondLabelYOffset = 5;
                this.hourLabelRadius = this.clockRadius - 40;
                this.hourLabelYOffset = 7;

                this.handData = [
                    {
                        type: 'hour',
                        value: 0,
                        length: -this.hourHandLength,
                        scale: this.hourScale
                    },
                    {
                        type: 'minute',
                        value: 0,
                        length: -this.minuteHandLength,
                        scale: this.minuteScale
                    }/*,
                    {
                        type: 'second',
                        value: 0,
                        length: -this.secondHandLength,
                        scale: this.secondScale,
                        balance: this.secondHandBalance
                    }*/
                ];

                this.drawClock()
                this.time = new Date();

                let _this = this;
                this.getPosition();
                this.visualizeClock();
            },

            methods: {
                lang: function (key) {
                    return this.language[this.selectedLanguage][key];
                },
                /**
                 * Get geo position
                */
                getPosition: function () {
                    let _this = this;
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(function (position) {
                            _this.lat = position.coords.latitude;
                            _this.long = position.coords.longitude;
                            _this.getSunTimes();
                        });
                    }
                },
                /**
                 * Get time of local sunrise and sunset
                */
                getSunTimes: function () {
                    if (!this.lat && !this.long) {
                        return;
                    }
                    let d = new Date();
                    let date = d.getFullYear() + '-' + this.pad(d.getMonth() + 1) + '-' + this.pad(d.getDate());
                    let url = 'https://api.met.no/weatherapi/sunrise/3.0/sun?lat=' + this.lat + '&lon=' + this.long + '&date=' + date + '&offset=-00:00';
                    let _this = this;

                    axios
                        .get(url)
                        .then(function (response) {
                            _this.rise = new Date(response.data.properties.sunrise.time);
                            _this.down = new Date(response.data.properties.sunset.time);
                            setInterval(function () {
                                _this.calcTemporalTime();
                                _this.calcSolarTime();
                            }, 1000);
                        })
                        .catch(e => {
                            console.log('err', url, e)
                        });
                },
                /**
                 * 
                */
                calcTemporalTime_updated() {
                    const now = new Date();
                    const midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
                    const nextMidnight = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0);

                    // TageslÃ¤nge (Sonnenaufgang bis Sonnenuntergang)
                    const dayLength = this.down.getTime() - this.rise.getTime();

                    // NachtlÃ¤nge (Sonnenuntergang bis Sonnenaufgang nÃ¤chster Tag)
                    const nightLength = (nextMidnight.getTime() - this.down.getTime()) +
                        (this.rise.getTime() - midnight.getTime());

                    let isNight = false;
                    let temporalHour, temporalMinute, progress, ratio;

                    // PrÃ¼fen ob Nacht
                    if (now.getTime() >= this.down.getTime() || now.getTime() < this.rise.getTime()) {
                        isNight = true;

                        // Fortschritt in der Nacht berechnen
                        if (now.getTime() >= this.down.getTime()) {
                            // Abend/Nacht bis Mitternacht
                            progress = now.getTime() - this.down.getTime();
                        } else {
                            // Nach Mitternacht bis Sonnenaufgang
                            progress = (nextMidnight.getTime() - this.down.getTime()) +
                                (now.getTime() - midnight.getTime());
                        }

                        // VerhÃ¤ltnis: wieviel der Nacht ist vergangen (0-1)
                        ratio = progress / nightLength;

                        // 12 Nachtstunden verteilen
                        const totalMinutes = ratio * 720; // 12 Stunden = 720 Minuten
                        temporalHour = Math.floor(totalMinutes / 60) + 1; // 1-12
                        temporalMinute = Math.floor(totalMinutes % 60);

                        // In normale Zeit umrechnen (fÃ¼r Anzeige)
                        const displayHour = this.down.getHours() + Math.floor(totalMinutes / 60);
                        const displayMinute = Math.floor(totalMinutes % 60);

                        this.temporalHour = temporalHour;
                        this.temporalMinute = temporalMinute;
                        this.updateData((displayHour % 12) + displayMinute / 60, displayMinute);

                    } else {
                        // Tag
                        isNight = false;

                        // Fortschritt im Tag
                        progress = now.getTime() - this.rise.getTime();
                        ratio = progress / dayLength;

                        // 12 Tagesstunden verteilen
                        const totalMinutes = ratio * 720;
                        temporalHour = Math.floor(totalMinutes / 60) + 1; // 1-12
                        temporalMinute = Math.floor(totalMinutes % 60);

                        // In normale Zeit umrechnen
                        const displayHour = this.rise.getHours() + Math.floor(totalMinutes / 60);
                        const displayMinute = Math.floor(totalMinutes % 60);

                        this.temporalHour = temporalHour;
                        this.temporalMinute = temporalMinute;
                        this.updateData((displayHour % 12) + displayMinute / 60, displayMinute);
                    }

                    this.moveHands();

                    // Zeitdifferenz zur normalen Zeit
                    this.timeDifference = Math.abs(
                        (this.temporalHour - now.getHours()) * 60 +
                        (this.temporalMinute - now.getMinutes())
                    );
                },
                /**
                 * Calculation of temporal time
                */
                calcTemporalTime() {
                    let now = new Date();
                    let start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
                    let end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 999);
                    let dayTime = this.down.getTime() - this.rise.getTime();
                    let nightTime =
                        this.rise.getTime() -
                        start.getTime() +
                        (end.getTime() - this.down.getTime());

                    this.tmp = dayTime + "_" + nightTime;

                    let isNight = false;
                    if (
                        now.getTime() < this.rise.getTime() ||
                        now.getTime() > this.down.getTime()
                    ) {
                        isNight = true;
                    } else {
                        isNight = false;
                    }

                    if (isNight) {
                        let progress = now.getTime() - this.down.getTime();
                        let tmp = progress / nightTime;
                        let hour = Math.ceil(Math.ceil(720 * tmp) / 60) + this.down.getHours();
                        let minute = (Math.ceil(720 * tmp) % 60) + this.down.getMinutes();
                        if (minute >= 60) {
                            minute = minute - 60;
                            hour = hour + 1;
                        }
                        this.temporalHour = hour;
                        this.temporalMinute = minute;
                        this.updateData(hour % 12 + minute / 60, minute);
                        this.moveHands();
                        this.timeDifference =
                            (hour - now.getHours()) * 60 +
                            Math.abs(now.getMinutes() - minute); // FIXME: ...

                    } else {
                        let progress = now.getTime() - this.rise.getTime();
                        let tmp = progress / dayTime;
                        let hour = Math.ceil(Math.ceil(720 * tmp) / 60) + this.rise.getHours();
                        let minute = (Math.ceil(720 * tmp) % 60) + this.rise.getMinutes();
                        if (minute >= 60) {
                            minute = minute - 60;
                            hour = hour + 1;
                        }
                        this.temporalHour = hour;
                        this.temporalMinute = minute;
                        this.updateData(hour % 12 + minute / 60, minute);
                        this.moveHands();
                    }
                },
                /**
                 * Adds a leading zero if the given number is lower than 10
                */
                pad: function (n) {
                    return n < 10 ? '0' + n : n;
                },
                /**
                 * Calculate solar time
                */
                calcSolarTime: function () {
                    const d = new Date();
                    const utc = d.getTime() + (d.getTimezoneOffset() * 60000);
                    const solarTime = new Date(utc + (this.long * 240000)); // 4 minutes pro degree
                    this.solarHour = solarTime.getUTCHours();
                    this.solarMinute = this.pad(solarTime.getUTCMinutes());
                },
                /**
                 * Format temporal, local, and solar time decimal format
                */
                getFormatedTime(type) {
                    // {{ tims()}}{{ temporalHour }}:{{  }}{{ solarHour }}:{{ solarMinute }}
                    let min = 0;
                    switch (type) {
                        case "temporal":
                            min = parseInt(this.temporalMinute);
                            min = this.pad(min);
                            return this.temporalHour + ':' + min;

                        case "local":
                            min = parseInt(this.time.getMinutes());
                            min = this.pad(min);
                            return this.time.getHours() + ':' + min;

                        case "solar":
                            min = parseInt(this.solarMinute);
                            min = this.pad(min);
                            return this.solarHour + ':' + min;
                        default:
                            return '0:00'
                    }
                },
                /**
                 * Visualise clock
                */
                visualizeClock: function () {
                    let _this = this;

                    //_this.drawClock();

                    /*
                    setInterval(function () {
                        _this.updateData();
                        _this.moveHands();
                    }, 1000);
                    */

                    //d3.select(self.frameElement).style("height", height + "px");

                },

                hourScale: d3.scale.linear()
                    .range([0, 330])
                    .domain([0, 11])
                ,

                minuteScale: d3.scale.linear()
                    .range([0, 354])
                    .domain([0, 59])
                ,

                secondScale: d3.scale.linear()
                    .range([0, 354])
                    .domain([0, 59])
                ,

                moveHands: function () {
                    d3.select('#clock-hands').selectAll('line')
                        .data(this.handData)
                        .transition()
                        .attr('transform', function (d) {
                            return 'rotate(' + d.scale(d.value) + ')';
                        });
                },

                updateData: function (hour, minute) {
                    var t = new Date();
                    if (hour === undefined && minute === undefined) {
                        this.handData[0].value = (t.getHours() % 12) + t.getMinutes() / 60;
                        this.handData[1].value = t.getMinutes();
                        //this.handData[2].value = t.getSeconds();
                    } else {
                        this.handData[0].value = hour;
                        this.handData[1].value = minute;
                        //this.handData[2].value = t.getSeconds();
                        //this.drawClock()
                    }

                },

                drawClock: function () { //create all the clock elements
                    let _this = this;
                    //this.updateData();	//draw them in the correct starting position

                    var svg = d3.select("#clock").append("svg")
                        .attr("width", this.width)
                        .attr("height", this.height);

                    var face = svg.append('g')
                        .attr('id', 'clock-face')
                        .attr('transform', 'translate(' + (this.clockRadius + this.margin) + ',' + (this.clockRadius + this.margin) + ')');

                    //add marks for seconds
                    face.selectAll('.second-tick')
                        .data(d3.range(0, 60)).enter()
                        .append('line')
                        .attr('class', 'second-tick')
                        .attr('x1', 0)
                        .attr('x2', 0)
                        .attr('y1', this.secondTickStart)
                        .attr('y2', this.secondTickStart + this.secondTickLength)
                        .attr('transform', function (d) {
                            return 'rotate(' + _this.secondScale(d) + ')';
                        });

                    //and labels

                    face.selectAll('.second-label')
                        .data(d3.range(5, 61, 5))
                        .enter()
                        .append('text')
                        .attr('class', 'second-label')
                        .attr('text-anchor', 'middle')
                        .attr('x', function (d) {
                            return _this.secondLabelRadius * Math.sin(_this.secondScale(d) * _this.radians);
                        })
                        .attr('y', function (d) {
                            return -_this.secondLabelRadius * Math.cos(_this.secondScale(d) * _this.radians) + _this.secondLabelYOffset;
                        })
                        .text(function (d) {
                            return d;
                        });

                    //... and hours
                    face.selectAll('.hour-tick')
                        .data(d3.range(0, 12)).enter()
                        .append('line')
                        .attr('class', 'hour-tick')
                        .attr('x1', 0)
                        .attr('x2', 0)
                        .attr('y1', _this.hourTickStart)
                        .attr('y2', _this.hourTickStart + _this.hourTickLength)
                        .attr('transform', function (d) {
                            return 'rotate(' + _this.hourScale(d) + ')';
                        });

                    face.selectAll('.hour-label')
                        .data(d3.range(3, 13, 3))
                        .enter()
                        .append('text')
                        .attr('class', 'hour-label')
                        .attr('text-anchor', 'middle')
                        .attr('x', function (d) {
                            return _this.hourLabelRadius * Math.sin(_this.hourScale(d) * _this.radians);
                        })
                        .attr('y', function (d) {
                            return -_this.hourLabelRadius * Math.cos(_this.hourScale(d) * _this.radians) + _this.hourLabelYOffset;
                        })
                        .text(function (d) {
                            return d;
                        });


                    var hands = face.append('g').attr('id', 'clock-hands');

                    face.append('g').attr('id', 'face-overlay')
                        .append('circle').attr('class', 'hands-cover')
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('r', _this.clockRadius / 20);

                    hands.selectAll('line')
                        .data(_this.handData)
                        .enter()
                        .append('line')
                        .attr('class', function (d) {
                            return d.type + '-hand';
                        })
                        .attr('x1', 0)
                        .attr('y1', function (d) {
                            return d.balance ? d.balance : 0;
                        })
                        .attr('x2', 0)
                        .attr('y2', function (d) {
                            return d.length;
                        })
                        .attr('transform', function (d) {
                            return 'rotate(' + d.scale(d.value) + ')';
                        });
                },
            },
            watch: {
                time: function () {
                    return new Date();
                },
            }
        }).mount('#app');
    </script>
</body>

</html>